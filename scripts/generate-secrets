#!/usr/bin/env bash

# ============================================
# SECRETS GENERATOR
# ============================================
# Generates secure passwords and JWT tokens
# Usage: ./scripts/generate-secrets

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/utils.sh"

print_banner

echo ""
log_step "Secure Secrets Generator"
echo ""

# Function to generate secure password
# Uses only alphanumeric characters to avoid URL encoding issues in database connection strings
generate_password() {
    local length=${1:-32}
    openssl rand -base64 48 | tr -d "=+/\n" | cut -c1-${length}
}

# Function to generate alphanumeric-only secret (for JWT and other secrets)
generate_alphanumeric_secret() {
    local length=${1:-32}
    openssl rand -base64 48 | tr -d "=+/\n" | cut -c1-${length}
}

# Check if .env exists
if [ -f .env ]; then
    log_warning ".env file already exists!"
    echo ""
    read -p "Do you want to OVERWRITE it? (type 'yes' to confirm): " confirm
    if [ "$confirm" != "yes" ]; then
        log_info "Cancelled. Your existing .env was not modified."
        exit 0
    fi
    # Backup existing .env
    cp .env .env.backup.$(date +%Y%m%d_%H%M%S)
    log_info "Backup created: .env.backup.*"
fi

# Get VPS information
echo ""
log_info "VPS Configuration"
echo ""
echo "Please provide your VPS details:"
echo ""

# VPS IP with validation
while true; do
    read -p "VPS IP address: " vps_host
    if [[ -n "$vps_host" ]]; then
        break
    fi
    echo "Error: IP address cannot be empty"
done

# VPS root password
while true; do
    read -sp "VPS root password: " vps_root_password
    echo ""
    if [[ -n "$vps_root_password" ]]; then
        break
    fi
    echo "Error: Password cannot be empty"
done

echo ""

# Generate all secrets
log_info "Generating secure passwords..."
DEPLOY_USER_PASSWORD=$(generate_password 32)
POSTGRES_PASSWORD=$(generate_password 32)
PG_ADMIN_PASSWORD=$(generate_password 32)
PG_MONITOR_PASSWORD=$(generate_password 32)
PG_REPLICATION_PASSWORD=$(generate_password 32)
PATRONI_PASSWORD=$(generate_password 32)
HAPROXY_ADMIN_PASSWORD=$(generate_password 32)
GRAFANA_ADMIN_PASSWORD=$(generate_password 32)
MINIO_ROOT_PASSWORD=$(generate_password 32)
S3_SECRET_KEY=$(generate_password 32)
DASHBOARD_PASSWORD=$(generate_password 32)
# JWT_SECRET must be at least 32 characters, using alphanumeric to avoid issues
JWT_SECRET=$(generate_alphanumeric_secret 40)
LOGFLARE_PUBLIC_TOKEN=$(openssl rand -hex 32)
LOGFLARE_PRIVATE_TOKEN=$(openssl rand -hex 32)
PGBACKREST_CIPHER_PASS=$(generate_alphanumeric_secret 32)
# PG_META_CRYPTO_KEY encrypts connection strings between Studio and postgres-meta (min 32 chars)
PG_META_CRYPTO_KEY=$(generate_alphanumeric_secret 32)
# SECRET_KEY_BASE for Realtime and other services
SECRET_KEY_BASE=$(generate_alphanumeric_secret 64)

log_success "Passwords generated"

# Generate JWT tokens
log_info "Generating JWT tokens..."

generate_jwt_token() {
    local role=$1
    local secret=$2

    local header='{"alg":"HS256","typ":"JWT"}'
    local payload="{\"role\":\"${role}\",\"iss\":\"supabase\",\"iat\":1641971400,\"exp\":4795571400}"

    local header_b64=$(echo -n "$header" | base64 | tr -d '=' | tr '/+' '_-')
    local payload_b64=$(echo -n "$payload" | base64 | tr -d '=' | tr '/+' '_-')
    local signature=$(echo -n "${header_b64}.${payload_b64}" | openssl dgst -sha256 -hmac "$secret" -binary | base64 | tr -d '=' | tr '/+' '_-')

    echo "${header_b64}.${payload_b64}.${signature}"
}

ANON_KEY=$(generate_jwt_token "anon" "${JWT_SECRET}")
SERVICE_ROLE_KEY=$(generate_jwt_token "service_role" "${JWT_SECRET}")

log_success "JWT tokens generated"

# Optional: Domain and SSL
echo ""
log_info "SSL/HTTPS Configuration (Optional)"
echo ""
echo "If you have a domain pointing to your VPS, you can enable HTTPS with Let's Encrypt."
echo "Example: bitsflaredb.bits.do → ${vps_host}"
echo ""
read -p "Enable HTTPS with Let's Encrypt? (y/N): " has_domain
if [[ "$has_domain" =~ ^[Yy]$ ]]; then
    while true; do
        read -p "Your domain (e.g., bitsflaredb.bits.do): " domain
        if [[ -n "$domain" ]]; then
            break
        fi
        echo "Error: Domain cannot be empty"
    done

    while true; do
        read -p "Your email for Let's Encrypt: " letsencrypt_email
        if [[ "$letsencrypt_email" =~ ^[^@]+@[^@]+\.[^@]+$ ]]; then
            break
        fi
        echo "Error: Please enter a valid email address"
    done

    USE_LETSENCRYPT="true"
    SUPABASE_DOMAIN="$domain"
    SUPABASE_API_EXTERNAL_URL="https://$domain"
    LETSENCRYPT_EMAIL="$letsencrypt_email"

    log_success "SSL will be configured for: https://${domain}"
else
    USE_LETSENCRYPT="false"
    SUPABASE_DOMAIN=""
    SUPABASE_API_EXTERNAL_URL=""
    LETSENCRYPT_EMAIL=""
    log_info "SSL skipped - you can configure it later with: ./scripts/deploy ssl:setup"
fi

# SMTP Configuration - Resend pre-configured
echo ""
log_info "SMTP Configuration (Resend)"
echo ""
echo "Email features: password reset, magic links, confirmations"
echo "Using Resend (smtp.resend.com) - Pre-configured"
echo ""

# Resend defaults (pre-configured for BITS)
SMTP_HOST="smtp.resend.com"
SMTP_PORT="587"
SMTP_USER="resend"
SMTP_PASSWORD="re_RC2jHu7y_GUwzCtvuBQDFcDhWJVk5vo5e"
SMTP_ADMIN_EMAIL="noreply@updates.bits.do"
SMTP_SENDER_NAME="Bits Supabase"

log_success "SMTP configured: ${SMTP_HOST} (${SMTP_ADMIN_EMAIL})"

# Storage Configuration - Use MinIO (local) by default
echo ""
log_info "Storage Configuration"
echo "Using MinIO (local S3-compatible storage)"
echo ""

S3_BUCKET="data"
S3_ENDPOINT=""
S3_REGION="stub"
S3_ACCESS_KEY="s3user_data"
S3_SECRET_KEY=$(generate_password 32)
S3_FORCE_PATH_STYLE="true"
S3_PROTOCOL="https"

PGBACKREST_S3_BUCKET=""
PGBACKREST_S3_ENDPOINT=""
PGBACKREST_S3_REGION=""
PGBACKREST_S3_ACCESS_KEY=""
PGBACKREST_S3_SECRET_KEY=""

log_success "Storage: MinIO (local)"

# Create .env file
log_info "Creating .env file..."

cat > .env << ENV_FILE
# ============================================
# PIGSTY SUPABASE - CONFIGURATION
# ============================================
# Generated: $(date)
# NEVER commit this file to git!

# ============================================
# VPS CONNECTION
# ============================================
VPS_HOST=${vps_host}
VPS_ROOT_PASSWORD=${vps_root_password}

# ============================================
# DEPLOY USER (created automatically)
# ============================================
DEPLOY_USER=deploy
DEPLOY_USER_PASSWORD=${DEPLOY_USER_PASSWORD}

# ============================================
# POSTGRESQL
# ============================================
POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
PG_ADMIN_PASSWORD=${PG_ADMIN_PASSWORD}

# PostgreSQL Internal Users (Pigsty)
PG_MONITOR_PASSWORD=${PG_MONITOR_PASSWORD}
PG_REPLICATION_PASSWORD=${PG_REPLICATION_PASSWORD}
PATRONI_PASSWORD=${PATRONI_PASSWORD}
HAPROXY_ADMIN_PASSWORD=${HAPROXY_ADMIN_PASSWORD}

# ============================================
# SUPABASE JWT (40+ characters required)
# ============================================
JWT_SECRET=${JWT_SECRET}
ANON_KEY=${ANON_KEY}
SERVICE_ROLE_KEY=${SERVICE_ROLE_KEY}

# ============================================
# SUPABASE DASHBOARD
# ============================================
DASHBOARD_USERNAME=supabase
DASHBOARD_PASSWORD=${DASHBOARD_PASSWORD}

# ============================================
# SUPABASE LOGFLARE (Analytics)
# ============================================
LOGFLARE_PUBLIC_ACCESS_TOKEN=${LOGFLARE_PUBLIC_TOKEN}
LOGFLARE_PRIVATE_ACCESS_TOKEN=${LOGFLARE_PRIVATE_TOKEN}

# ============================================
# SUPABASE INTERNAL KEYS
# ============================================
# Encrypts connection strings between Studio and postgres-meta
PG_META_CRYPTO_KEY=${PG_META_CRYPTO_KEY}
# Secret key for Realtime and other services
SECRET_KEY_BASE=${SECRET_KEY_BASE}

# ============================================
# MONITORING
# ============================================
GRAFANA_ADMIN_PASSWORD=${GRAFANA_ADMIN_PASSWORD}

# ============================================
# STORAGE (S3-compatible)
# ============================================
MINIO_ROOT_USER=minioadmin
MINIO_ROOT_PASSWORD=${MINIO_ROOT_PASSWORD}

# S3 Configuration (Backblaze B2, AWS S3, MinIO, etc.)
S3_BUCKET=${S3_BUCKET}
S3_ENDPOINT=${S3_ENDPOINT}
S3_REGION=${S3_REGION}
S3_ACCESS_KEY=${S3_ACCESS_KEY}
S3_SECRET_KEY=${S3_SECRET_KEY}
S3_FORCE_PATH_STYLE=${S3_FORCE_PATH_STYLE}
S3_PROTOCOL=${S3_PROTOCOL}

# ============================================
# OPTIONAL: DOMAIN & SSL
# ============================================
SUPABASE_DOMAIN=${SUPABASE_DOMAIN}
SUPABASE_API_EXTERNAL_URL=${SUPABASE_API_EXTERNAL_URL}
LETSENCRYPT_EMAIL=${LETSENCRYPT_EMAIL}
USE_LETSENCRYPT=${USE_LETSENCRYPT}

# ============================================
# OPTIONAL: SMTP (for email features)
# ============================================
SMTP_HOST=${SMTP_HOST}
SMTP_PORT=${SMTP_PORT}
SMTP_USER=${SMTP_USER}
SMTP_PASSWORD=${SMTP_PASSWORD}
SMTP_SENDER_NAME=${SMTP_SENDER_NAME}
SMTP_ADMIN_EMAIL=${SMTP_ADMIN_EMAIL}

# ============================================
# PGBACKREST - PostgreSQL Backup & Recovery
# ============================================
PGBACKREST_ENABLED=true
PGBACKREST_METHOD=s3
PGBACKREST_S3_BUCKET=${PGBACKREST_S3_BUCKET}
PGBACKREST_S3_ENDPOINT=${PGBACKREST_S3_ENDPOINT}
PGBACKREST_S3_REGION=${PGBACKREST_S3_REGION}
PGBACKREST_S3_ACCESS_KEY=${PGBACKREST_S3_ACCESS_KEY}
PGBACKREST_S3_SECRET_KEY=${PGBACKREST_S3_SECRET_KEY}
PGBACKREST_CIPHER_PASS=${PGBACKREST_CIPHER_PASS}

# Backup Retention (14 days = 2 weeks of backups)
PGBACKREST_RETENTION_FULL=14

# Local Backup Repository (for faster restores)
PGBACKREST_LOCAL_ENABLED=true
PGBACKREST_LOCAL_RETENTION_FULL=2
ENV_FILE

log_success ".env file created"

# Display summary
echo ""
log_step "Configuration Summary"
echo ""
echo -e "${GREEN}VPS:${NC}"
echo "  Host: ${vps_host}"
echo ""
echo -e "${GREEN}Access Credentials (save these securely!):${NC}"
echo ""
echo -e "${YELLOW}Deploy User:${NC}"
echo "  Username: deploy"
echo "  Password: ${DEPLOY_USER_PASSWORD}"
echo ""
echo -e "${YELLOW}PostgreSQL:${NC}"
echo "  Admin Password: ${PG_ADMIN_PASSWORD}"
echo "  Supabase Password: ${POSTGRES_PASSWORD}"
echo ""
echo -e "${YELLOW}Grafana:${NC}"
echo "  Username: admin"
echo "  Password: ${GRAFANA_ADMIN_PASSWORD}"
echo ""
echo -e "${YELLOW}MinIO:${NC}"
echo "  Username: minioadmin"
echo "  Password: ${MINIO_ROOT_PASSWORD}"
echo ""
echo -e "${YELLOW}JWT Secret:${NC}"
echo "  ${JWT_SECRET}"
echo ""

if [ "$USE_LETSENCRYPT" = "true" ]; then
    echo -e "${GREEN}Domain:${NC}"
    echo "  ${SUPABASE_DOMAIN}"
    echo "  SSL: Enabled (Let's Encrypt)"
    echo ""
fi

if [ -n "$SMTP_HOST" ]; then
    echo -e "${GREEN}SMTP:${NC}"
    echo "  Host: ${SMTP_HOST}:${SMTP_PORT}"
    echo "  Configured: Yes"
    echo ""
fi

echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "${YELLOW}⚠ IMPORTANT: Save these credentials securely!${NC}"
echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo ""
echo -e "${GREEN}✓ Configuration complete!${NC}"
echo ""
echo -e "${GREEN}Next steps:${NC}"
echo ""
echo -e "  ${CYAN}1.${NC} Review configuration:"
echo -e "     ${YELLOW}cat .env${NC}"
echo ""
echo -e "  ${CYAN}2.${NC} Deploy everything:"
echo -e "     ${YELLOW}./scripts/deploy all${NC}"
echo ""
if [ "$USE_LETSENCRYPT" = "true" ]; then
    echo -e "  ${CYAN}3.${NC} After deployment completes, setup SSL:"
    echo -e "     ${YELLOW}./scripts/deploy ssl:setup${NC}"
    echo ""
    echo -e "  ${GREEN}Note:${NC} Make sure ${SUPABASE_DOMAIN} DNS points to ${vps_host}"
    echo ""
fi
echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo ""
