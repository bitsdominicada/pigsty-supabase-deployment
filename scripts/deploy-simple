#!/usr/bin/env bash
#==============================================================#
# File      :   deploy-simple
# Desc      :   Simplified deployment using official Pigsty flow
# Path      :   scripts/deploy-simple
# Usage     :   ./scripts/deploy-simple all
# Copyright :   2025 - Automation Script
# License   :   AGPLv3
#==============================================================#

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

source "${SCRIPT_DIR}/utils.sh"

#--------------------------------------------------------------#
# Generate pigsty.yml using official ./configure + inject vars
#--------------------------------------------------------------#
generate_pigsty_config() {
    log_step "Generating pigsty.yml with official Pigsty configure"

    load_env

    # Copy .env to VPS temporarily (will be used by inject-vars.py)
    log_info "Copying .env to VPS..."
    sshpass -p "${DEPLOY_USER_PASSWORD}" scp \
        -i ~/.ssh/pigsty_deploy \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o LogLevel=ERROR \
        "${PROJECT_ROOT}/.env" \
        "${DEPLOY_USER}@${VPS_HOST}:/tmp/.env.pigsty"

    # Copy inject-vars.py script to VPS
    log_info "Copying inject-vars.py to VPS..."
    sshpass -p "${DEPLOY_USER_PASSWORD}" scp \
        -i ~/.ssh/pigsty_deploy \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o LogLevel=ERROR \
        "${PROJECT_ROOT}/lib/inject-vars.py" \
        "${DEPLOY_USER}@${VPS_HOST}:/tmp/inject-vars.py"

    # Run ./configure on VPS to generate base pigsty.yml
    log_info "Running ./configure -c app/supa on VPS..."
    sshpass -p "${DEPLOY_USER_PASSWORD}" ssh \
        -i ~/.ssh/pigsty_deploy \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o LogLevel=ERROR \
        "${DEPLOY_USER}@${VPS_HOST}" \
        "cd ~/pigsty && ./configure -c app/supa -i ${VPS_HOST} -n"

    log_success "Base pigsty.yml generated by Pigsty configure"

    # Inject our variables into pigsty.yml
    log_info "Injecting custom variables into pigsty.yml..."
    sshpass -p "${DEPLOY_USER_PASSWORD}" ssh \
        -i ~/.ssh/pigsty_deploy \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o LogLevel=ERROR \
        "${DEPLOY_USER}@${VPS_HOST}" \
        "python3 /tmp/inject-vars.py ~/pigsty/pigsty.yml /tmp/.env.pigsty"

    log_success "Variables injected into pigsty.yml"

    # Display configuration summary
    echo ""
    log_info "Configuration summary:"
    echo "  Domain:      ${SUPABASE_DOMAIN}"
    echo "  VPS IP:      ${VPS_HOST}"
    echo "  SSL Email:   ${LETSENCRYPT_EMAIL}"
    echo "  SSL Enabled: ${USE_LETSENCRYPT}"
    echo "  B2 Bucket:   ${S3_BUCKET}"
    echo "  B2 Endpoint: ${S3_ENDPOINT}"
    echo ""

    # Cleanup temporary files from VPS
    log_info "Cleaning up temporary files..."
    sshpass -p "${DEPLOY_USER_PASSWORD}" ssh \
        -i ~/.ssh/pigsty_deploy \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o LogLevel=ERROR \
        "${DEPLOY_USER}@${VPS_HOST}" \
        "rm -f /tmp/.env.pigsty /tmp/inject-vars.py"

    log_success "pigsty.yml configured successfully"
}

#--------------------------------------------------------------#
# Prepare VPS (same as before)
#--------------------------------------------------------------#
prepare_vps() {
    log_step "Preparing VPS"
    "${SCRIPT_DIR}/modules/01-prepare.sh"
}

#--------------------------------------------------------------#
# Download Pigsty
#--------------------------------------------------------------#
download_pigsty() {
    log_step "Downloading Pigsty"

    load_env

    log_info "Installing Pigsty v3.6.1 on VPS..."

    sshpass -p "${DEPLOY_USER_PASSWORD}" ssh \
        -i ~/.ssh/pigsty_deploy \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o LogLevel=ERROR \
        "${DEPLOY_USER}@${VPS_HOST}" \
        "curl -fsSL https://repo.pigsty.io/get | bash"

    log_success "Pigsty downloaded and extracted"
}

#--------------------------------------------------------------#
# Update Supabase container versions to latest
#--------------------------------------------------------------#
update_supabase_versions() {
    load_env
    log_step "Updating Supabase container versions"

    log_info "Patching ~/pigsty/app/supabase/docker-compose.yml with latest versions..."

    # Define version updates (Pigsty -> Official latest)
    # These are the versions from Supabase official docker-compose.yml as of 2025-11
    sshpass -p "${DEPLOY_USER_PASSWORD}" ssh \
        -i ~/.ssh/pigsty_deploy \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o LogLevel=ERROR \
        "${DEPLOY_USER}@${VPS_HOST}" \
        "cd ~/pigsty/app/supabase && \
        # Studio: 2025.06.16 -> 2025.11.10
        sed -i 's|supabase/studio:2025.06.16-sha-c4316c3|supabase/studio:2025.11.10-sha-5291fe3|g' docker-compose.yml && \
        # Auth (GoTrue): v2.174.0 -> v2.182.1
        sed -i 's|supabase/gotrue:v2.174.0|supabase/gotrue:v2.182.1|g' docker-compose.yml && \
        # PostgREST: v12.2.12 -> v13.0.7
        sed -i 's|postgrest/postgrest:v12.2.12|postgrest/postgrest:v13.0.7|g' docker-compose.yml && \
        # Realtime: v2.34.47 -> v2.63.0
        sed -i 's|supabase/realtime:v2.34.47|supabase/realtime:v2.63.0|g' docker-compose.yml && \
        # Storage: v1.23.0 -> v1.29.0
        sed -i 's|supabase/storage-api:v1.23.0|supabase/storage-api:v1.29.0|g' docker-compose.yml && \
        # Meta: v0.89.3 -> v0.93.1
        sed -i 's|supabase/postgres-meta:v0.89.3|supabase/postgres-meta:v0.93.1|g' docker-compose.yml && \
        # Edge Functions: v1.67.4 -> v1.69.23
        sed -i 's|supabase/edge-runtime:v1.67.4|supabase/edge-runtime:v1.69.23|g' docker-compose.yml && \
        # Analytics (Logflare): 1.15.4 -> 1.22.6
        sed -i 's|supabase/logflare:1.15.4|supabase/logflare:1.22.6|g' docker-compose.yml && \
        echo 'Versions updated successfully'

        # Add PG_META_CRYPTO_KEY to studio and meta services if not present
        if ! grep -q 'PG_META_CRYPTO_KEY' docker-compose.yml; then
            # Add to studio service (after POSTGRES_PASSWORD line)
            sed -i '/POSTGRES_PASSWORD.*POSTGRES_PASSWORD/a\\      PG_META_CRYPTO_KEY: \${PG_META_CRYPTO_KEY}' docker-compose.yml
            # Add to meta service (after PG_META_DB_PASSWORD line)
            sed -i '/PG_META_DB_PASSWORD/a\\      CRYPTO_KEY: \${PG_META_CRYPTO_KEY}' docker-compose.yml
            echo 'Added PG_META_CRYPTO_KEY to docker-compose.yml'
        fi

        # Add missing POSTGRES_* vars to Studio (required for newer versions)
        # Fix for: Failed to retrieve migration history / Zod validation error
        if ! grep -q 'POSTGRES_HOST.*POSTGRES_HOST' docker-compose.yml; then
            sed -i '/POSTGRES_PASSWORD: \\\${POSTGRES_PASSWORD}/a\\      POSTGRES_HOST: \${POSTGRES_HOST}\n      POSTGRES_PORT: \${POSTGRES_PORT}\n      POSTGRES_DB: \${POSTGRES_DB}' docker-compose.yml
            echo 'Added POSTGRES_HOST/PORT/DB to Studio'
        fi

        # Add SMTP configuration to auth service (GoTrue)
        if ! grep -q 'SMTP_HOST' docker-compose.yml; then
            # Find the auth service and add SMTP vars after GOTRUE_EXTERNAL_EMAIL_ENABLED
            sed -i '/GOTRUE_EXTERNAL_EMAIL_ENABLED/a\\      SMTP_HOST: \${SMTP_HOST}\n      SMTP_PORT: \${SMTP_PORT}\n      SMTP_USER: \${SMTP_USER}\n      SMTP_PASS: \${SMTP_PASSWORD}\n      SMTP_SENDER_NAME: \${SMTP_SENDER_NAME}\n      SMTP_ADMIN_EMAIL: \${SMTP_ADMIN_EMAIL}' docker-compose.yml
            echo 'Added SMTP configuration to auth service'
        fi"

    log_success "Container versions updated to latest"
    log_info "Updated versions:"
    echo "  studio:    2025.11.10-sha-5291fe3"
    echo "  gotrue:    v2.182.1"
    echo "  postgrest: v13.0.7"
    echo "  realtime:  v2.63.0"
    echo "  storage:   v1.29.0"
    echo "  meta:      v0.93.1"
    echo "  functions: v1.69.23"
    echo "  logflare:  1.22.6"
}

#--------------------------------------------------------------#
# Bootstrap Ansible
#--------------------------------------------------------------#
bootstrap_ansible() {
    load_env
    log_step "Bootstrapping Ansible"

    log_info "Installing Ansible and dependencies..."

    sshpass -p "${DEPLOY_USER_PASSWORD}" ssh \
        -i ~/.ssh/pigsty_deploy \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o LogLevel=ERROR \
        "${DEPLOY_USER}@${VPS_HOST}" \
        "cd ~/pigsty && ./bootstrap"

    log_success "Ansible bootstrapped"
}

#--------------------------------------------------------------#
# Install Pigsty Stack (PostgreSQL + MinIO + Infra)
#--------------------------------------------------------------#
install_pigsty() {
    load_env
    log_step "Installing Pigsty Stack"

    log_info "This will take 10-20 minutes..."
    log_info "Installing: PostgreSQL 17, Patroni, MinIO, Grafana, Prometheus..."

    sshpass -p "${DEPLOY_USER_PASSWORD}" ssh \
        -i ~/.ssh/pigsty_deploy \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o LogLevel=ERROR \
        "${DEPLOY_USER}@${VPS_HOST}" \
        "cd ~/pigsty && ./install.yml"

    log_success "Pigsty stack installed"
    log_info "PostgreSQL 17 with Patroni: âœ“"
    log_info "MinIO S3 storage: âœ“"
    log_info "Monitoring (Grafana, Prometheus): âœ“"

    if [ "${USE_LETSENCRYPT:-false}" = "true" ]; then
        log_info "SSL Certificate: âœ“ (Let's Encrypt)"
        log_info "Domain: https://${SUPABASE_DOMAIN}"
    fi
}

#--------------------------------------------------------------#
# Install Docker
#--------------------------------------------------------------#
install_docker() {
    load_env
    log_step "Installing Docker"

    log_info "Installing Docker and Docker Compose..."

    sshpass -p "${DEPLOY_USER_PASSWORD}" ssh \
        -i ~/.ssh/pigsty_deploy \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o LogLevel=ERROR \
        "${DEPLOY_USER}@${VPS_HOST}" \
        "cd ~/pigsty && ./docker.yml"

    log_success "Docker installed"
}

#--------------------------------------------------------------#
# Apply Backblaze B2 / S3-compatible fixes
#--------------------------------------------------------------#
#--------------------------------------------------------------#
# Fix Vault functions to use pgsodium server key
#--------------------------------------------------------------#
fix_vault_pgsodium() {
    load_env
    log_step "Fixing Vault to use pgsodium server key"

    log_info "Patching vault functions to use pgsodium native encryption..."

    # The supabase_vault extension has its own C functions that don't share
    # the server key with pgsodium. We replace them with pgsodium native functions.

    # Create SQL patch file on VPS
    sshpass -p "${DEPLOY_USER_PASSWORD}" ssh \
        -i ~/.ssh/pigsty_deploy \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o LogLevel=ERROR \
        "${DEPLOY_USER}@${VPS_HOST}" \
        "cat > /tmp/vault_fix.sql << 'EOF'
-- Fix vault.create_secret to use pgsodium native function
CREATE OR REPLACE FUNCTION vault.create_secret(new_secret text, new_name text DEFAULT NULL::text, new_description text DEFAULT ''::text, new_key_id uuid DEFAULT NULL::uuid)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS \$function\$
DECLARE
  rec record;
BEGIN
  INSERT INTO vault.secrets (secret, name, description)
  VALUES (new_secret, new_name, new_description)
  RETURNING * INTO rec;
  UPDATE vault.secrets s
  SET secret = encode(pgsodium.crypto_aead_det_encrypt(
    message := convert_to(rec.secret, 'utf8'),
    additional := convert_to(s.id::text, 'utf8'),
    key_id := 0::bigint,
    context := 'pgsodium'::bytea,
    nonce := rec.nonce
  ), 'base64')
  WHERE id = rec.id;
  RETURN rec.id;
END
\$function\$;

-- Fix vault.decrypted_secrets view to use pgsodium native function
CREATE OR REPLACE VIEW vault.decrypted_secrets AS
 SELECT id, name, description, secret,
    convert_from(pgsodium.crypto_aead_det_decrypt(
        message => decode(secret, 'base64'::text),
        additional => convert_to(id::text, 'utf8'::name),
        key_id => 0::bigint,
        context => '\x7067736f6469756d'::bytea,
        nonce => nonce
    ), 'utf8'::name) AS decrypted_secret,
    key_id, nonce, created_at, updated_at
   FROM vault.secrets s;

-- Fix vault.update_secret to use pgsodium native function
CREATE OR REPLACE FUNCTION vault.update_secret(secret_id uuid, new_secret text DEFAULT NULL::text, new_name text DEFAULT NULL::text, new_description text DEFAULT NULL::text, new_key_id uuid DEFAULT NULL::uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS \$function\$
DECLARE
  decrypted_secret text := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE id = secret_id);
BEGIN
  UPDATE vault.secrets s
  SET
    secret = CASE WHEN new_secret IS NULL THEN s.secret
                  ELSE encode(pgsodium.crypto_aead_det_encrypt(
                    message := convert_to(new_secret, 'utf8'),
                    additional := convert_to(s.id::text, 'utf8'),
                    key_id := 0::bigint,
                    context := 'pgsodium'::bytea,
                    nonce := s.nonce
                  ), 'base64') END,
    name = coalesce(new_name, s.name),
    description = coalesce(new_description, s.description),
    updated_at = now()
  WHERE s.id = secret_id;
END
\$function\$;
EOF
"

    # Apply the SQL patch
    sshpass -p "${DEPLOY_USER_PASSWORD}" ssh \
        -i ~/.ssh/pigsty_deploy \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o LogLevel=ERROR \
        "${DEPLOY_USER}@${VPS_HOST}" \
        "sudo -u postgres psql -d postgres -f /tmp/vault_fix.sql && rm /tmp/vault_fix.sql"

    log_success "Vault functions patched to use pgsodium server key"
}

#--------------------------------------------------------------#
# Launch Supabase
#--------------------------------------------------------------#
launch_supabase() {
    load_env
    log_step "Launching Supabase"

    log_info "Starting Supabase containers (11 services)..."

    sshpass -p "${DEPLOY_USER_PASSWORD}" ssh \
        -i ~/.ssh/pigsty_deploy \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o LogLevel=ERROR \
        "${DEPLOY_USER}@${VPS_HOST}" \
        "cd ~/pigsty && ./app.yml"

    log_success "Supabase launched"

    # Fix Vault to use pgsodium server key
    fix_vault_pgsodium

    # Wait a bit for containers to start
    log_info "Waiting for services to start..."
    sleep 15

    # Check container status
    log_info "Checking container status..."
    sshpass -p "${DEPLOY_USER_PASSWORD}" ssh \
        -i ~/.ssh/pigsty_deploy \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o LogLevel=ERROR \
        "${DEPLOY_USER}@${VPS_HOST}" \
        "sudo docker ps --format 'table {{.Names}}\t{{.Status}}' | grep supabase"
}

#--------------------------------------------------------------#
# Verify deployment
#--------------------------------------------------------------#
verify_deployment() {
    log_step "Verifying Deployment"

    load_env

    # Check container count
    local container_count=$(sshpass -p "${DEPLOY_USER_PASSWORD}" ssh \
        -i ~/.ssh/pigsty_deploy \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o LogLevel=ERROR \
        "${DEPLOY_USER}@${VPS_HOST}" \
        "sudo docker ps | grep supabase | wc -l")

    if [ "${container_count}" -eq 11 ]; then
        log_success "All 11 Supabase containers running"
    else
        log_warning "Only ${container_count}/11 containers running"
    fi

    # Check HTTPS
    if [ "${USE_LETSENCRYPT:-false}" = "true" ]; then
        log_info "Testing HTTPS access..."
        if curl -sI "https://${SUPABASE_DOMAIN}" | grep -q "HTTP"; then
            log_success "HTTPS working: https://${SUPABASE_DOMAIN}"
        else
            log_warning "HTTPS may not be working yet"
        fi
    fi

    # Check PostgreSQL
    log_info "PostgreSQL available at: ${VPS_HOST}:5436"

    # Check Grafana
    log_info "Grafana available at: http://${VPS_HOST}"

    echo ""
    print_deployment_summary
}

#--------------------------------------------------------------#
# Print deployment summary
#--------------------------------------------------------------#
print_deployment_summary() {
    load_env

    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "  Deployment Complete!"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "ğŸŒ Supabase:"
    if [ "${USE_LETSENCRYPT:-false}" = "true" ]; then
        echo "   URL:      https://${SUPABASE_DOMAIN}"
    else
        echo "   URL:      http://${VPS_HOST}:8000"
    fi
    echo "   User:     supabase"
    echo "   Password: ${DASHBOARD_PASSWORD:-pigsty}"
    echo ""
    echo "ğŸ“Š Grafana:"
    echo "   URL:      http://${VPS_HOST}"
    echo "   User:     admin"
    echo "   Password: ${GRAFANA_ADMIN_PASSWORD}"
    echo ""
    echo "ğŸ—„ï¸  PostgreSQL:"
    echo "   Host:     ${VPS_HOST}:5436"
    echo "   Database: postgres"
    echo "   User:     supabase_admin"
    echo "   Password: ${POSTGRES_PASSWORD}"
    echo ""
    echo "â˜ï¸  Backblaze B2:"
    echo "   Bucket:   ${S3_BUCKET}"
    echo "   Endpoint: ${S3_ENDPOINT}"
    echo "   Status:   Configured"
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
}

#--------------------------------------------------------------#
# Full deployment
#--------------------------------------------------------------#
deploy_all() {
    print_banner

    log_info "Starting simplified Pigsty deployment..."
    log_info "Using official Pigsty configuration with automated substitutions"
    echo ""

    prepare_vps
    download_pigsty
    update_supabase_versions
    generate_pigsty_config
    bootstrap_ansible

    # Validate configuration before proceeding
    "${SCRIPT_DIR}/modules/03-validate.sh"

    install_pigsty
    install_docker
    launch_supabase
    verify_deployment

    log_success "Deployment completed successfully!"
}

#--------------------------------------------------------------#
# Main
#--------------------------------------------------------------#
main() {
    case "${1:-help}" in
        all)
            deploy_all
            ;;
        config)
            generate_pigsty_config
            ;;
        validate)
            "${SCRIPT_DIR}/modules/03-validate.sh"
            ;;
        verify)
            verify_deployment
            ;;
        *)
            print_banner
            echo "Usage: $0 {all|config|validate|verify}"
            echo ""
            echo "Commands:"
            echo "  all      - Full deployment (recommended)"
            echo "  config   - Generate and upload pigsty.yml only"
            echo "  validate - Validate pigsty.yml configuration"
            echo "  verify   - Verify deployment status"
            echo ""
            echo "Example:"
            echo "  $0 all"
            ;;
    esac
}

main "$@"
