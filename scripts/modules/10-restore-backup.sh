#!/usr/bin/env bash

# ============================================
# MODULE: Restore Database Backups
# ============================================
# Restores clean database backups after Supabase deployment
# Use backups generated by 11-create-backup.sh for best results

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
source "${SCRIPT_DIR}/utils.sh"

BACKUP_DIR="${PROJECT_ROOT}/db_backup"

restore_backups() {
    log_step "Restoring Database Backups"

    load_env

    # Check if backup directory exists
    if [ ! -d "${BACKUP_DIR}" ]; then
        log_warning "No backup directory found at ${BACKUP_DIR}, skipping restore"
        return 0
    fi

    # Check for required files
    if [ ! -f "${BACKUP_DIR}/postgres.dump" ]; then
        log_warning "No postgres.dump found, skipping restore"
        return 0
    fi

    log_info "Found backups to restore:"
    ls -lh "${BACKUP_DIR}"/*.dump "${BACKUP_DIR}"/*.sql 2>/dev/null || true
    echo ""

    # Detect SSH key
    local ssh_key=""
    if [ -n "${SSH_KEY_PATH:-}" ] && [ -f "${SSH_KEY_PATH}" ]; then
        ssh_key="${SSH_KEY_PATH}"
    elif [ -f "$HOME/.ssh/id_ed25519" ]; then
        ssh_key="$HOME/.ssh/id_ed25519"
    elif [ -f "$HOME/.ssh/id_rsa" ]; then
        ssh_key="$HOME/.ssh/id_rsa"
    fi

    # Upload backups to VPS
    log_info "Uploading backups to VPS..."
    ssh_exec "mkdir -p /tmp/db_restore"

    scp -i "${ssh_key}" \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o LogLevel=ERROR \
        "${BACKUP_DIR}"/*.dump "${BACKUP_DIR}"/*.sql \
        "${SSH_USER}@${VPS_HOST}:/tmp/db_restore/" 2>/dev/null

    log_success "Backups uploaded"

    # Stop Supabase containers to avoid conflicts
    log_info "Stopping Supabase containers..."
    ssh_exec "cd /opt/supabase && sudo docker compose stop" || true
    sleep 5

    # Restore globals (roles)
    log_info "Restoring global roles..."
    ssh_exec "sudo -u postgres psql -f /tmp/db_restore/globals.sql 2>&1 | grep -v 'already exists' | grep -v 'NOTICE' || true"

    # Restore postgres database
    log_info "Restoring postgres database..."
    ssh_exec "sudo -u postgres pg_restore \
        --dbname=postgres \
        --clean \
        --if-exists \
        --no-owner \
        --no-privileges \
        /tmp/db_restore/postgres.dump 2>&1 | grep -E 'error|ERROR' || echo 'Restore completed'" || true

    # Restore supabase database if exists
    if [ -f "${BACKUP_DIR}/supabase.dump" ]; then
        log_info "Restoring supabase analytics database..."
        ssh_exec "sudo -u postgres pg_restore \
            --dbname=supabase \
            --clean \
            --if-exists \
            --no-owner \
            --no-privileges \
            /tmp/db_restore/supabase.dump 2>&1 | grep -E 'error|ERROR' || echo 'Restore completed'" || true
    fi

    # Restart Supabase containers
    log_info "Restarting Supabase containers..."
    ssh_exec "cd /opt/supabase && sudo docker compose up -d"

    # Wait for services
    log_info "Waiting for services to start..."
    sleep 20

    # Cleanup
    ssh_exec "rm -rf /tmp/db_restore"

    # Verify
    local table_count=$(ssh_exec "sudo -u postgres psql -d postgres -t -c \"SELECT count(*) FROM pg_tables WHERE schemaname NOT IN ('pg_catalog', 'information_schema');\"" | tr -d ' ')

    log_info "Container status:"
    ssh_exec "sudo docker ps --format 'table {{.Names}}\t{{.Status}}' | head -12"

    log_success "Database restore completed! Found ${table_count} tables."
}

# Run if executed directly
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    restore_backups
fi
