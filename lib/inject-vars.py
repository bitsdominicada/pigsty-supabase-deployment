#!/usr/bin/env python3
"""
Inject Variables into Pigsty Configuration

Reads .env file and injects values into apps.supabase.conf section
of pigsty.yml generated by ./configure -c app/supa

This is simpler than generating the entire YAML from scratch.
We only replace specific values in the official template.
"""

import os
import re
import sys
from pathlib import Path


def load_env(env_file):
    """Load environment variables from .env file"""
    env = {}

    if not os.path.exists(env_file):
        print(f"Error: {env_file} not found", file=sys.stderr)
        sys.exit(1)

    with open(env_file) as f:
        for line in f:
            line = line.strip()
            # Skip comments and empty lines
            if line and not line.startswith("#") and "=" in line:
                # Split only on first =
                key, value = line.split("=", 1)
                # Strip inline comments from values
                value = value.split("#")[0].strip()
                env[key.strip()] = value.strip().strip('"').strip("'")

    return env


def replace_conf_value(content, key, value):
    """
    Replace a value in the apps.supabase.conf section

    Pattern matches:
      KEY: old-value
    And replaces with:
      KEY: new-value

    Preserves indentation and formatting.
    """
    # Match the key followed by colon and value
    # Capture the indentation before the key
    pattern = rf"^(\s*){key}:\s*.*$"
    replacement = rf"\1{key}: {value}"

    content = re.sub(pattern, replacement, content, flags=re.MULTILINE)

    return content


def add_smtp_config(content, env):
    """
    Add SMTP configuration to apps.supabase.conf section

    The official template has SMTP commented out.
    We need to uncomment and set values.
    """
    smtp_host = env.get("SMTP_HOST", "")

    if not smtp_host:
        return content

    smtp_config = f"""              SMTP_ADMIN_EMAIL: {env.get("SMTP_ADMIN_EMAIL", "")}
              SMTP_HOST: {env.get("SMTP_HOST", "")}
              SMTP_PORT: {env.get("SMTP_PORT", "587")}
              SMTP_USER: {env.get("SMTP_USER", "")}
              SMTP_PASS: {env.get("SMTP_PASSWORD", "")}
              SMTP_SENDER_NAME: {env.get("SMTP_SENDER_NAME", "")}"""

    # Find where to inject SMTP config (after S3 config, before closing)
    # Look for the pattern with MINIO_DOMAIN_IP or S3_REGION
    pattern = (
        r"(\s+S3_REGION:.*\n)(\s+# if using SMTP.*\n\s+#SMTP.*\n.*\n.*\n.*\n.*\n.*\n)?"
    )
    replacement = rf"\1{smtp_config}\n"

    # Try to replace commented SMTP section
    if re.search(pattern, content):
        content = re.sub(pattern, replacement, content)
    else:
        # If not found, add after S3_REGION
        pattern = r"(\s+S3_REGION:.*\n)"
        replacement = rf"\1{smtp_config}\n"
        content = re.sub(pattern, replacement, content)

    print(f"  ✓ Added SMTP configuration: {smtp_host}", file=sys.stderr)

    return content


def add_tus_s3_tags_fix(content, env):
    """
    Add TUS_ALLOW_S3_TAGS=false for Backblaze B2, Cloudflare R2, DigitalOcean Spaces

    These S3-compatible providers don't support x-amz-tagging header which causes
    resumable uploads to fail. Setting this to false disables S3 tagging for TUS uploads.
    """
    s3_endpoint = env.get("S3_ENDPOINT", "")

    # Detect if using S3-compatible provider that needs this fix
    needs_fix = any(
        provider in s3_endpoint.lower()
        for provider in [
            "backblazeb2.com",
            "r2.cloudflarestorage.com",
            "digitaloceanspaces.com",
        ]
    )

    if not needs_fix:
        return content

    # Add TUS_ALLOW_S3_TAGS after SMTP config (or after S3_REGION if no SMTP)
    tus_config = "              TUS_ALLOW_S3_TAGS: false"

    # Try to add after SMTP_SENDER_NAME
    pattern = r"(\s+SMTP_SENDER_NAME:.*\n)"
    if re.search(pattern, content):
        replacement = rf"\1{tus_config}\n"
        content = re.sub(pattern, replacement, content)
    else:
        # If no SMTP, add after S3_REGION
        pattern = r"(\s+S3_REGION:.*\n)"
        replacement = rf"\1{tus_config}\n"
        content = re.sub(pattern, replacement, content)

    print(f"  ✓ Added TUS_ALLOW_S3_TAGS=false for {s3_endpoint}", file=sys.stderr)

    return content


def add_pg_meta_crypto_key(content, env):
    """
    Add PG_META_CRYPTO_KEY to apps.supabase.conf

    This key is required by supabase-meta but not included in Pigsty's template.
    """
    pg_meta_key = env.get("PG_META_CRYPTO_KEY", "")

    if not pg_meta_key:
        return content

    # Add after POSTGRES_PASSWORD
    crypto_key_line = f"              PG_META_CRYPTO_KEY: {pg_meta_key}"
    pattern = r"(\s+POSTGRES_PASSWORD:.*\n)"
    replacement = rf"\1{crypto_key_line}\n"
    content = re.sub(pattern, replacement, content)

    print(f"  ✓ Added PG_META_CRYPTO_KEY", file=sys.stderr)

    return content


def inject_variables(pigsty_yml, env):
    """
    Inject all variables from .env into pigsty.yml
    """
    with open(pigsty_yml) as f:
        content = f.read()

    print("Injecting variables into pigsty.yml...", file=sys.stderr)

    # Map .env variables to pigsty.yml conf keys
    # Some variables have different names
    mappings = [
        # PostgreSQL
        ("POSTGRES_PASSWORD", "POSTGRES_PASSWORD"),
        ("VPS_HOST", "POSTGRES_HOST"),
        ("VPS_HOST", "MINIO_DOMAIN_IP"),
        # JWT & Keys
        ("JWT_SECRET", "JWT_SECRET"),
        ("ANON_KEY", "ANON_KEY"),
        ("SERVICE_ROLE_KEY", "SERVICE_ROLE_KEY"),
        # Dashboard
        ("DASHBOARD_USERNAME", "DASHBOARD_USERNAME"),
        ("DASHBOARD_PASSWORD", "DASHBOARD_PASSWORD"),
        # Logflare
        ("LOGFLARE_PUBLIC_ACCESS_TOKEN", "LOGFLARE_PUBLIC_ACCESS_TOKEN"),
        ("LOGFLARE_PRIVATE_ACCESS_TOKEN", "LOGFLARE_PRIVATE_ACCESS_TOKEN"),
        # S3/Storage
        ("S3_BUCKET", "S3_BUCKET"),
        ("S3_ENDPOINT", "S3_ENDPOINT"),
        ("S3_ACCESS_KEY", "S3_ACCESS_KEY"),
        ("S3_SECRET_KEY", "S3_SECRET_KEY"),
        ("S3_REGION", "S3_REGION"),
        ("S3_FORCE_PATH_STYLE", "S3_FORCE_PATH_STYLE"),
        ("S3_PROTOCOL", "S3_PROTOCOL"),
        # Domain & URLs
        ("SUPABASE_API_EXTERNAL_URL", "SITE_URL"),
        ("SUPABASE_API_EXTERNAL_URL", "API_EXTERNAL_URL"),
        ("SUPABASE_API_EXTERNAL_URL", "SUPABASE_PUBLIC_URL"),
    ]

    for env_key, conf_key in mappings:
        if env_key in env:
            value = env[env_key]
            content = replace_conf_value(content, conf_key, value)
            print(f"  ✓ {conf_key} = {value[:50]}...", file=sys.stderr)

    # Add SMTP configuration
    content = add_smtp_config(content, env)

    # Add TUS_ALLOW_S3_TAGS fix for Backblaze B2 / S3-compatible providers
    content = add_tus_s3_tags_fix(content, env)

    # Add PG_META_CRYPTO_KEY (not in Pigsty template)
    content = add_pg_meta_crypto_key(content, env)

    # Also update non-conf variables (outside apps.supabase.conf)
    # These are in the global vars section

    # Update certbot configuration if HTTPS enabled
    if env.get("USE_LETSENCRYPT", "false").lower() == "true":
        content = replace_global_var(content, "certbot_sign", "true")
        content = replace_global_var(
            content, "certbot_email", env.get("LETSENCRYPT_EMAIL", "")
        )
        print(f"  ✓ Enabled certbot for HTTPS", file=sys.stderr)

    # Configure domains for Supabase with multiple infra_portal entries
    # According to Pigsty docs, each domain needs its own entry in infra_portal
    # See: https://pigsty.io/docs/app/supabase/
    #
    # We need three entries:
    #   - api.domain -> Kong API (port 8000)
    #   - studio.domain -> Supabase Studio (port 3000)
    #   - domain -> Main app/Kong (port 8000)
    if "SUPABASE_DOMAIN" in env:
        domain = env["SUPABASE_DOMAIN"]
        api_domain = f"api.{domain}"
        studio_domain = f"studio.{domain}"
        vps_ip = env.get("VPS_HOST", "10.10.10.10")

        # Replace the single 'supa' entry with three separate entries
        # The supa entry in pigsty.yml can be either:
        # 1. Single line: supa: { domain: supa.pigsty, ... }
        # 2. Multi-line:
        #      supa: # comment
        #        domain: supa.pigsty
        #        endpoint: "..."
        #        websocket: true
        #        certbot: supa.pigsty

        # New multi-domain configuration (multi-line format to match template style)
        new_portal_entries = f"""supa: # API endpoint (Kong)
        domain: {api_domain}
        endpoint: "{vps_ip}:8000"
        websocket: true
        certbot: {api_domain}
      studio: # Supabase Studio
        domain: {studio_domain}
        endpoint: "{vps_ip}:3000"
        websocket: true
        certbot: {studio_domain}
      app: # Main app domain (Kong)
        domain: {domain}
        endpoint: "{vps_ip}:8000"
        websocket: true
        certbot: {domain}"""

        # Try multi-line format first (more common in templates)
        # Pattern: supa: # comment\n + indented lines until next entry at same level
        multiline_pattern = r"(\s*)supa:\s*#[^\n]*\n(?:\1\s+\w+:[^\n]*\n)+"
        if re.search(multiline_pattern, content):
            content = re.sub(
                multiline_pattern,
                f"      {new_portal_entries}\n",
                content,
            )
        else:
            # Fallback: single-line format { ... }
            content = re.sub(
                r"^\s*supa\s*:\s*\{[^}]+\}\s*$",
                f"      {new_portal_entries}",
                content,
                flags=re.MULTILINE,
            )

        # Also update endpoint IP in case it uses 10.10.10.10 placeholder
        content = re.sub(
            r'endpoint:\s*"10\.10\.10\.10:',
            f'endpoint: "{vps_ip}:',
            content,
        )

        # Replace in /etc/hosts line - add all three domains
        # Pattern in node_etc_hosts: "- 10.10.10.10 i.pigsty sss.pigsty supa.pigsty"
        content = re.sub(
            r"(node_etc_hosts:.*?- [0-9.]+\s+[^\n]*?)supa\.pigsty",
            rf"\1{api_domain} {studio_domain} {domain}",
            content,
            flags=re.DOTALL,
        )

        print(f"  ✓ Multi-domain infra_portal configured:", file=sys.stderr)
        print(f"      API:    {api_domain} -> {vps_ip}:8000 (Kong)", file=sys.stderr)
        print(f"      Studio: {studio_domain} -> {vps_ip}:3000", file=sys.stderr)
        print(f"      App:    {domain} -> {vps_ip}:8000 (Kong)", file=sys.stderr)

    # Add pg_hba rule to allow connections from VPS IP (for supabase-analytics container)
    # Supabase containers connect from host IP when using host networking or POSTGRES_HOST=<public_ip>
    if "VPS_HOST" in env:
        vps_ip = env["VPS_HOST"]

        # Pigsty v3.7.0 uses compact single-line format for pg_hba_rules:
        # pg_hba_rules:
        #   - { user: all ,db: postgres  ,addr: 172.17.0.0/16 ,auth: pwd ,title: 'allow access from local docker network' }

        # Pattern: Match the docker network rule line and add our rule after it
        hba_pattern = r"(-\s*\{\s*user:\s*all\s*,\s*db:\s*postgres\s*,\s*addr:\s*172\.17\.0\.0/16\s*,\s*auth:\s*pwd\s*,\s*title:\s*'allow access from local docker network'\s*\})"
        new_hba_rule = rf"\1\n          - {{ user: all ,db: all ,addr: {vps_ip}/32 ,auth: pwd ,title: 'allow supabase access from host IP' }}"

        if re.search(hba_pattern, content):
            content = re.sub(hba_pattern, new_hba_rule, content)
            print(
                f"  ✓ Added pg_hba rule for {vps_ip}/32 (all databases)",
                file=sys.stderr,
            )
        else:
            # Fallback: Try to find any pg_hba_rules section and append
            # Match the last rule in pg_hba_rules (any format)
            fallback_pattern = r"(pg_hba_rules:[^\n]*\n(?:\s+-[^\n]+\n)*?)(\s+-\s*\{[^}]+\}\s*\n)(\s*(?:node_crontab|[a-z_]+:|\n\s*#))"
            match = re.search(fallback_pattern, content, flags=re.DOTALL)
            if match:
                # Get indentation from existing rule
                existing_rule = match.group(2)
                indent_match = re.match(r"(\s+)", existing_rule)
                indent = indent_match.group(1) if indent_match else "          "
                new_rule = f"{indent}- {{ user: all ,db: all ,addr: {vps_ip}/32 ,auth: pwd ,title: 'allow supabase access from host IP' }}\n"
                content = content[: match.end(2)] + new_rule + content[match.start(3) :]
                print(
                    f"  ✓ Added pg_hba rule for {vps_ip}/32 (fallback method)",
                    file=sys.stderr,
                )
            else:
                print(
                    f"  ⚠ Could not find pg_hba_rules section to add host IP rule",
                    file=sys.stderr,
                )

    # Replace 'DBUser.Supa' password in all Supabase pg_users with actual password
    # Pigsty does NOT resolve variables - it uses literal strings as passwords
    if "POSTGRES_PASSWORD" in env:
        password = env["POSTGRES_PASSWORD"]
        # Replace all instances of "password: 'DBUser.Supa'" with actual password
        content = re.sub(
            r"password:\s*'DBUser\.Supa'", f"password: '{password}'", content
        )
        print(
            f"  ✓ Replaced all 'DBUser.Supa' passwords with actual value",
            file=sys.stderr,
        )

    # Update passwords for Pigsty services
    password_mappings = [
        ("GRAFANA_ADMIN_PASSWORD", "grafana_admin_password"),
        ("PG_ADMIN_PASSWORD", "pg_admin_passwd"),
        ("PG_MONITOR_PASSWORD", "pg_monitor_passwd"),
        ("PG_REPLICATION_PASSWORD", "pg_replication_passwd"),
    ]

    for env_key, yml_key in password_mappings:
        if env_key in env:
            content = replace_global_var(content, yml_key, env[env_key])
            print(f"  ✓ {yml_key} updated", file=sys.stderr)

    # Ensure node_repo_modules includes 'docker' for Docker repository
    # Default in Pigsty supabase.yml is 'node,pgsql,infra' which doesn't include docker
    # Without this, docker-ce package won't be found on Ubuntu
    if "node_repo_modules:" in content:
        # Check if docker is already included
        if not re.search(r"node_repo_modules:.*docker", content):
            # Add docker to existing modules
            content = re.sub(
                r"(node_repo_modules:\s*)([^\n]+)",
                r"\1\2,docker",
                content,
            )
            print(f"  ✓ Added 'docker' to node_repo_modules", file=sys.stderr)
    else:
        # Add node_repo_modules if not present
        # Find the all: vars section and add it
        content = re.sub(
            r"(all:\s*\n\s*vars:\s*\n)",
            r"\1    node_repo_modules: node,pgsql,infra,docker\n",
            content,
        )
        print(f"  ✓ Added node_repo_modules with docker", file=sys.stderr)

    # Write modified pigsty.yml
    with open(pigsty_yml, "w") as f:
        f.write(content)

    print(f"\n✅ Variables injected successfully into {pigsty_yml}", file=sys.stderr)


def replace_global_var(content, key, value):
    """
    Replace a global variable (outside apps section)
    """
    # Match key at the start of line with proper indentation
    pattern = rf"^(\s*){key}:\s*.*$"
    replacement = rf"\1{key}: {value}"

    return re.sub(pattern, replacement, content, flags=re.MULTILINE)


def main():
    if len(sys.argv) < 3:
        print("Usage: inject-vars.py <pigsty.yml> <.env>", file=sys.stderr)
        print("", file=sys.stderr)
        print("Example:", file=sys.stderr)
        print(
            "  python3 inject-vars.py ~/pigsty/pigsty.yml /tmp/.env.pigsty",
            file=sys.stderr,
        )
        sys.exit(1)

    pigsty_yml = sys.argv[1]
    env_file = sys.argv[2]

    if not os.path.exists(pigsty_yml):
        print(f"Error: {pigsty_yml} not found", file=sys.stderr)
        sys.exit(1)

    # Load environment variables
    env = load_env(env_file)

    # Inject variables
    inject_variables(pigsty_yml, env)


if __name__ == "__main__":
    main()
