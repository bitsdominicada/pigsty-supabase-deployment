#!/usr/bin/env python3
"""
Inject Variables into Pigsty Configuration

Reads .env file and injects values into apps.supabase.conf section
of pigsty.yml generated by ./configure -c app/supa

This is simpler than generating the entire YAML from scratch.
We only replace specific values in the official template.
"""

import os
import re
import sys
from pathlib import Path


def load_env(env_file):
    """Load environment variables from .env file"""
    env = {}

    if not os.path.exists(env_file):
        print(f"Error: {env_file} not found", file=sys.stderr)
        sys.exit(1)

    with open(env_file) as f:
        for line in f:
            line = line.strip()
            # Skip comments and empty lines
            if line and not line.startswith("#") and "=" in line:
                # Split only on first =
                key, value = line.split("=", 1)
                # Strip inline comments from values
                value = value.split("#")[0].strip()
                env[key.strip()] = value.strip().strip('"').strip("'")

    return env


def replace_conf_value(content, key, value):
    """
    Replace a value in the apps.supabase.conf section

    Pattern matches:
      KEY: old-value
    And replaces with:
      KEY: new-value

    Preserves indentation and formatting.
    """
    # Match the key followed by colon and value
    # Capture the indentation before the key
    pattern = rf"^(\s*){key}:\s*.*$"
    replacement = rf"\1{key}: {value}"

    content = re.sub(pattern, replacement, content, flags=re.MULTILINE)

    return content


def add_smtp_config(content, env):
    """
    Add SMTP configuration to apps.supabase.conf section

    The official template has SMTP commented out.
    We need to uncomment and set values.
    """
    smtp_host = env.get("SMTP_HOST", "")

    if not smtp_host:
        return content

    smtp_config = f"""              SMTP_ADMIN_EMAIL: {env.get("SMTP_ADMIN_EMAIL", "")}
              SMTP_HOST: {env.get("SMTP_HOST", "")}
              SMTP_PORT: {env.get("SMTP_PORT", "587")}
              SMTP_USER: {env.get("SMTP_USER", "")}
              SMTP_PASS: {env.get("SMTP_PASSWORD", "")}
              SMTP_SENDER_NAME: {env.get("SMTP_SENDER_NAME", "")}"""

    # Find where to inject SMTP config (after S3 config, before closing)
    # Look for the pattern with MINIO_DOMAIN_IP or S3_REGION
    pattern = (
        r"(\s+S3_REGION:.*\n)(\s+# if using SMTP.*\n\s+#SMTP.*\n.*\n.*\n.*\n.*\n.*\n)?"
    )
    replacement = rf"\1{smtp_config}\n"

    # Try to replace commented SMTP section
    if re.search(pattern, content):
        content = re.sub(pattern, replacement, content)
    else:
        # If not found, add after S3_REGION
        pattern = r"(\s+S3_REGION:.*\n)"
        replacement = rf"\1{smtp_config}\n"
        content = re.sub(pattern, replacement, content)

    print(f"  ✓ Added SMTP configuration: {smtp_host}", file=sys.stderr)

    return content


def add_tus_s3_tags_fix(content, env):
    """
    Add TUS_ALLOW_S3_TAGS=false for Backblaze B2, Cloudflare R2, DigitalOcean Spaces

    These S3-compatible providers don't support x-amz-tagging header which causes
    resumable uploads to fail. Setting this to false disables S3 tagging for TUS uploads.
    """
    s3_endpoint = env.get("S3_ENDPOINT", "")

    # Detect if using S3-compatible provider that needs this fix
    needs_fix = any(
        provider in s3_endpoint.lower()
        for provider in [
            "backblazeb2.com",
            "r2.cloudflarestorage.com",
            "digitaloceanspaces.com",
        ]
    )

    if not needs_fix:
        return content

    # Add TUS_ALLOW_S3_TAGS after SMTP config (or after S3_REGION if no SMTP)
    tus_config = "              TUS_ALLOW_S3_TAGS: false"

    # Try to add after SMTP_SENDER_NAME
    pattern = r"(\s+SMTP_SENDER_NAME:.*\n)"
    if re.search(pattern, content):
        replacement = rf"\1{tus_config}\n"
        content = re.sub(pattern, replacement, content)
    else:
        # If no SMTP, add after S3_REGION
        pattern = r"(\s+S3_REGION:.*\n)"
        replacement = rf"\1{tus_config}\n"
        content = re.sub(pattern, replacement, content)

    print(f"  ✓ Added TUS_ALLOW_S3_TAGS=false for {s3_endpoint}", file=sys.stderr)

    return content


def inject_variables(pigsty_yml, env):
    """
    Inject all variables from .env into pigsty.yml
    """
    with open(pigsty_yml) as f:
        content = f.read()

    print("Injecting variables into pigsty.yml...", file=sys.stderr)

    # Map .env variables to pigsty.yml conf keys
    # Some variables have different names
    mappings = [
        # PostgreSQL
        ("POSTGRES_PASSWORD", "POSTGRES_PASSWORD"),
        ("VPS_HOST", "POSTGRES_HOST"),
        ("VPS_HOST", "MINIO_DOMAIN_IP"),
        # JWT & Keys
        ("JWT_SECRET", "JWT_SECRET"),
        ("ANON_KEY", "ANON_KEY"),
        ("SERVICE_ROLE_KEY", "SERVICE_ROLE_KEY"),
        ("PG_META_CRYPTO_KEY", "PG_META_CRYPTO_KEY"),
        # Dashboard
        ("DASHBOARD_USERNAME", "DASHBOARD_USERNAME"),
        ("DASHBOARD_PASSWORD", "DASHBOARD_PASSWORD"),
        # Logflare
        ("LOGFLARE_PUBLIC_ACCESS_TOKEN", "LOGFLARE_PUBLIC_ACCESS_TOKEN"),
        ("LOGFLARE_PRIVATE_ACCESS_TOKEN", "LOGFLARE_PRIVATE_ACCESS_TOKEN"),
        # S3/Storage
        ("S3_BUCKET", "S3_BUCKET"),
        ("S3_ENDPOINT", "S3_ENDPOINT"),
        ("S3_ACCESS_KEY", "S3_ACCESS_KEY"),
        ("S3_SECRET_KEY", "S3_SECRET_KEY"),
        ("S3_REGION", "S3_REGION"),
        ("S3_FORCE_PATH_STYLE", "S3_FORCE_PATH_STYLE"),
        ("S3_PROTOCOL", "S3_PROTOCOL"),
        # Domain & URLs
        ("SUPABASE_API_EXTERNAL_URL", "SITE_URL"),
        ("SUPABASE_API_EXTERNAL_URL", "API_EXTERNAL_URL"),
        ("SUPABASE_API_EXTERNAL_URL", "SUPABASE_PUBLIC_URL"),
    ]

    for env_key, conf_key in mappings:
        if env_key in env:
            value = env[env_key]
            content = replace_conf_value(content, conf_key, value)
            print(f"  ✓ {conf_key} = {value[:50]}...", file=sys.stderr)

    # Add SMTP configuration
    content = add_smtp_config(content, env)

    # Add TUS_ALLOW_S3_TAGS fix for Backblaze B2 / S3-compatible providers
    content = add_tus_s3_tags_fix(content, env)

    # Also update non-conf variables (outside apps.supabase.conf)
    # These are in the global vars section

    # Update certbot configuration if HTTPS enabled
    if env.get("USE_LETSENCRYPT", "false").lower() == "true":
        content = replace_global_var(content, "certbot_sign", "true")
        content = replace_global_var(
            content, "certbot_email", env.get("LETSENCRYPT_EMAIL", "")
        )
        print(f"  ✓ Enabled certbot for HTTPS", file=sys.stderr)

    # Update domain in infra_portal.supa
    if "SUPABASE_DOMAIN" in env:
        domain = env["SUPABASE_DOMAIN"]
        # Replace domain in infra_portal supa section
        content = re.sub(
            r"(supa\s*:\s*\n\s*domain:\s*)supa\.pigsty", rf"\1{domain}", content
        )
        # Replace in /etc/hosts line (keep other pigsty domains, only replace supa.pigsty)
        content = re.sub(r"(\s+)supa\.pigsty(\s|$)", rf"\1{domain}\2", content)
        # Replace certbot domain
        content = re.sub(r"(certbot:\s*)supa\.pigsty", rf"\1{domain}", content)
        print(f"  ✓ Domain configured: {domain}", file=sys.stderr)

    # Add pg_hba rule to allow connections from VPS IP (for supabase-analytics container)
    if "VPS_HOST" in env:
        vps_ip = env["VPS_HOST"]
        # Find pg_hba_rules section and add rule for VPS IP if not already there
        hba_pattern = r"(pg_hba_rules:.*?addr: 172\.17\.0\.0/16.*?title:.*?\n)"
        new_hba_rule = rf"\1          - {{ user: all ,db: all  ,addr: {vps_ip}/32 ,auth: pwd ,title: 'allow supabase access from host IP' }}\n"
        content = re.sub(hba_pattern, new_hba_rule, content, flags=re.DOTALL)
        print(f"  ✓ Added pg_hba rule for {vps_ip}/32 (all databases)", file=sys.stderr)

    # Add DBUser.Supa variable for Supabase users (insert after grafana_admin_password)
    if "POSTGRES_PASSWORD" in env:
        dbuser_supa_line = f"    DBUser.Supa: {env['POSTGRES_PASSWORD']}"
        # Insert after grafana_admin_password line
        content = re.sub(
            r"(grafana_admin_password:.*\n)", rf"\1{dbuser_supa_line}\n", content
        )
        print(f"  ✓ DBUser.Supa added/updated", file=sys.stderr)

    # Update passwords for Pigsty services
    password_mappings = [
        ("GRAFANA_ADMIN_PASSWORD", "grafana_admin_password"),
        ("PG_ADMIN_PASSWORD", "pg_admin_passwd"),
        ("PG_MONITOR_PASSWORD", "pg_monitor_passwd"),
        ("PG_REPLICATION_PASSWORD", "pg_replication_passwd"),
    ]

    for env_key, yml_key in password_mappings:
        if env_key in env:
            content = replace_global_var(content, yml_key, env[env_key])
            print(f"  ✓ {yml_key} updated", file=sys.stderr)

    # Write modified pigsty.yml
    with open(pigsty_yml, "w") as f:
        f.write(content)

    print(f"\n✅ Variables injected successfully into {pigsty_yml}", file=sys.stderr)


def replace_global_var(content, key, value):
    """
    Replace a global variable (outside apps section)
    """
    # Match key at the start of line with proper indentation
    pattern = rf"^(\s*){key}:\s*.*$"
    replacement = rf"\1{key}: {value}"

    return re.sub(pattern, replacement, content, flags=re.MULTILINE)


def main():
    if len(sys.argv) < 3:
        print("Usage: inject-vars.py <pigsty.yml> <.env>", file=sys.stderr)
        print("", file=sys.stderr)
        print("Example:", file=sys.stderr)
        print(
            "  python3 inject-vars.py ~/pigsty/pigsty.yml /tmp/.env.pigsty",
            file=sys.stderr,
        )
        sys.exit(1)

    pigsty_yml = sys.argv[1]
    env_file = sys.argv[2]

    if not os.path.exists(pigsty_yml):
        print(f"Error: {pigsty_yml} not found", file=sys.stderr)
        sys.exit(1)

    # Load environment variables
    env = load_env(env_file)

    # Inject variables
    inject_variables(pigsty_yml, env)


if __name__ == "__main__":
    main()
